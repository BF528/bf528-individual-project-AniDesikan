SUBSETFILES = ['subsetATACrep3', 'subsetATACrep4']
FILES = ['ATACrep3','ATACrep4']
READS = ['R1','R2']
PAIR = ['FP','FUP', 'RP', 'RUP']

rule all:
	input:
		#directory('genome_index_full'),
		#expand('results/sorted_{condition}_{rep}.bam.bai', condition = FILES, rep = READS)
		expand('results/{condition}_motifs_new/', condition = FILES)
		#'results/peaks_repr_filtered_annotations_new.txt'
		#expand('results/{condition}_{rep}.bam', condition = FILES, rep = READS)
		#'results/ATACrep3_R1_peaks.bed'



rule bowtie2_build_gencode:
	input:
		genome = 'results/hg38.fa.gz'
	output:
		dir = 'genome_index_full'
	params:
	threads: 16
	conda:
		'envs/bowtie2_env.yml'
	shell:
		'''
		bowtie2-build {input.genome} {output.dir}
		'''



rule fastqc:
	input:
		fastq = 'samples/{condition}_{rep}.fastq.gz'
	output:
		fastqc = 'results/{condition}_{rep}_fastqc.html'
	params:
		outdir = 'results/'
	threads: 4
	conda:
		'envs/fastqc_env.yml'
	shell:
		'''
		fastqc {input.fastq} -o {params.outdir}
		'''

rule trimomatic:
	input:
		read1 = 'samples/{condition}_R1.fastq.gz',
		read2 = 'samples/{condition}_R2.fastq.gz',
		adapters = 'samples/NexteraPE-PE.fa'
	output:
		forward_paired = 'results/{condition}_R1_FP_trimmed.fastq.gz',
		forward_unpaired = 'results/{condition}_R1_FUP_trimmed.fastq.gz',
		reverse_paired = 'results/{condition}_R2_RP_trimmed.fastq.gz',
		reverse_unpaired = 'results/{condition}_R2_RUP_trimmed.fastq.gz'
	threads: 8
	conda:
		'envs/trimmomatic_env.yml'
	shell:
		'''
		trimmomatic PE {input.read1} {input.read2} {output.forward_paired} {output.forward_unpaired} {output.reverse_paired} {output.reverse_unpaired} ILLUMINACLIP:{input.adapters}:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15
		'''

rule bowtie2_align:
	input:
		forward_paired = 'results/{condition}_R1_FP_trimmed.fastq.gz',
		reverse_paired = 'results/{condition}_R2_RP_trimmed.fastq.gz',
	output:
		bam = 'results/{condition}_{rep}.bam'
	threads: 32
	params:
	conda: 
		'envs/bowtie2_env.yml'
	shell:
		'''
		bowtie2 -p {threads} -x genome_index_full -1 {input.forward_paired} -2 {input.reverse_paired} | samtools view -Sb > {output.bam}
		'''

rule samtools_sort:
	input:
		bam = 'results/{condition}_{rep}.bam'
	output:
		sorted = 'results/sorted_{condition}_{rep}.bam'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools sort {input.bam} -o {output.sorted}
		'''

rule samtools_idx:
	input:
		sorted = 'results/sorted_{condition}_{rep}.bam'
	output:
		indexed = 'results/sorted_{condition}_{rep}.bam.bai'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools index {input.sorted} 
		'''

rule samtools_flagstat:
	input:
		indexed = 'results/sorted_{condition}_{rep}.bam'
	output:
		flagstat = 'results/flagstat_{condition}_{rep}.txt'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools flagstat {input.indexed} > {output.flagstat}
		'''

rule multiqc:
	input: expand('results/{reps}.{bams}.txt', reps = REPS, bams = BAMS),
		expand('results/{reps}_{reads}_fastqc.html', reps = REPS, reads = READS),
		expand('results/{reps}_{pairs}_fastqc.html', reps = REPS, pairs = PAIRS)
	output: 'results/multiqc_report.html'
	params: 
			indir = 'results',
			outdir = 'results'
	conda: 'envs/multiqc_env.yml'
	shell: '''
		multiqc {params.indir} -o {params.outdir}
		'''


# Remove any mitochondrial reads with 
#samtools	view input.bam |	egrep	-v	chrM	| samtools	view	-bT genome_index_full --o output.bam
#TODO
rule remove_mito_reads:
	input:
		indexed = 'results/sorted_{condition}_{rep}.bam'
	output:
		removed_mito = 'results/mito_{condition}_{rep}.bam'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools view -x MT {input.indexed} -o {output.removed_mito}
		'''

rule samtools_idx_mito:
	input:
		sorted = 'results/mito_{condition}_{rep}.bam'
	output:
		indexed = 'results/mito_{condition}_{rep}.bam.bai'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools index {input.sorted} 
		'''


# Using deeptools, shift bam files using alignmentSieve to account for tagmentation
#TODO
rule shift_bam_files:
	input:
		removed_mito = 'results/mito_{condition}_{rep}.bam',
		indexed = 'results/mito_{condition}_{rep}.bam.bai'
	output:
		shifted = 'results/shift_{condition}_{rep}.bam'
	conda:
		'envs/deeptools_env.yml'
	shell:
		'''
		alignmentSieve -b {input.removed_mito} -o {output.shifted} --filterMetrics new_log.txt --ATACshift
		'''

rule samtools_sort_shift:
	input:
		bam = 'results/shift_{condition}_{rep}.bam'
	output:
		sorted = 'results/sortedshift_{condition}_{rep}.bam'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools sort {input.bam} -o {output.sorted}
		'''

rule samtools_idx_shift:
	input:
		sorted = 'results/sortedshift_{condition}_{rep}.bam'
	output:
		indexed = 'results/sortedshift_{condition}_{rep}.bam.bai'
	conda:
		'envs/samtools_env.yml'
	shell:
		'''
		samtools index {input.sorted} 
		'''

# Perform QC on these shifted bam files using ATACseqQC using R

# Call peaks on bed files with default params using MACS
# Assume the bam files are pair ended and use -f format BAMPE
rule call_peaks:
	input: 'results/sortedshift_{condition}_{reps}.bam'
	output: 'results/{condition}_{reps}_summits.bed'
	params:
		outdir = 'results'
	conda: 'envs/macs3_env.yml'
	shell: '''
		macs3 callpeak -t {input} -f BAM \
		-n {params.name} --outdir {params.outdir} -g mm --nomodel
		'''	

rule intersect_peaks:
	input:
		a = 'results/ATACrep3_summits.bed',
		b = 'results/ATACrep4_summits.bed'
	output: 'results/ATAC_intersect.bed'
	conda: 'envs/bedtools_env.yml'
	shell: '''
		bedtools intersect -a {input.a} -b {input.b} -f 0.5  > {output}
		'''

rule filter_blacklist:
	input:
		peaks = 'results/ATAC_intersect.bed',
		blacklist = 'results/mm39.excluderanges.bed'
	output: 'results/ATAC_filtered.bed'
	conda: 'envs/bedtools_env.yml'
	shell: '''
		bedtools intersect -a {input.peaks} -b {input.blacklist} -v > {output}
		'''

rule annotate_peaks:
	input:
		filtered = 'results/ATAC_filtered.bed',
		annotation = 'results/gencode.v45.primary_assembly.annotation.gtf'
	output: 'results/ATAC_annotated.bed'
	conda: 'envs/homer_env.yml'
	shell: '''
		annotatePeaks.pl {input.filtered} mm39 -gtf {input.annotation} > {output}
		'''

rule motifs:
	input:
		peaks = 'results/ATAC_filtered.bed',
		genome = 'results/GRCh38.primary_assembly.genome.fa'
	output: directory('results/ATAC_motifs')
	conda: 'envs/homer_env.yml'
	shell: '''
		findMotifsGenome.pl {input.peaks} {input.genome} {output} -size 200
		'''

# Coverage plots for NFR/NBR
rule deeptools_filter:
	input: bam = 'results/{REPS}.shiftsort.bam',
		index = 'results/{REPS}.shiftsort.bam.bai'
	output: 'results/{REPS}_{min}_{max}.sep.bam'
	conda: 'envs/deeptools_env.yml'
	shell: '''
		alignmentSieve -b {input.bam} -o {output} \
		--minFragmentLength {wildcards.min} \
		--maxFragmentLength {wildcards.max}
		'''

rule samtools_idx_filter:
	input: 'results/{REPS}_{min}_{max}.sep.bam'
	output: 'results/{REPS}_{min}_{max}.sep.bam.bai'
	conda: 'envs/samtools_env.yml'
	shell: '''
		samtools index -b {input} -o {output}
		'''

rule bamCoverage:
	input: 
		bam = 'results/{REPS}_{min}_{max}.sep.bam',
		index = 'results/{REPS}_{min}_{max}.sep.bam.bai'
	output: 'results/{REPS}_{min}_{max}.bw'
	threads: 4
	conda: 'envs/deeptools_env.yml'
	shell: '''
		bamCoverage -b {input.bam} -o {output}
		'''

rule computeMatrix:
	input:
		atac = 'results/{REPS}_{min}_{max}.bw',
		regions = 'results/mm39_genes.bed'
	output: 'results/matrix_{REPS}_{min}_{max}.gz'
	params:
		upstream = 2000,
		downstream = 2000
	conda: 'envs/deeptools_env.yml'
	threads: 4
	shell: '''computeMatrix reference-point -R {input.regions} \
			-S {input.atac} \
			-o {output} \
			-b {params.upstream} -a {params.downstream}
			'''

rule plotMatrix:
	input: 'results/matrix_{REPS}_{min}_{max}.gz'
	output: 'results/signal_coverage_{REPS}_{min}_{max}.png'
	conda: 'envs/deeptools_env.yml'
	shell: '''plotProfile -m {input} -o {output}'''
